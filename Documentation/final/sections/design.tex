\section{Design}
    \subsection{Algorithms}
        \begin{itemize}
            \item $\begin{aligned}[t]
                arccos(x)
            \end{aligned}$
                Located in FunctionArccos.py
                \paragraph{}
                The Arccos function also known as the inverse of cos can be expressed in many forms, though the formula that we will be using is as follows:

                \begin{center}
                    $\cos^{-1}(x) = \frac{1}{2}(\pi - 2sin^{-1}(x))$
                \end{center}

                \paragraph{}
                As the formula itself is quite direct, the complex part is to define the value of arcsin(x), which has its own equation. For simplicity, this section explains how to achieve just the arccos, where the arcsin(x) algorithm can be found in the arcsin(x) section. The translation of this formula can be seen in the pseudo code in Python below. Note, for a full detailed algorithm of the arccos, please open the FunctionArccos.py file.

                \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionArccos
Input: num, a real number
Output: arccos(num)

result (*$\leftarrow$*) ((*$\pi$*)/2) - FunctionArcsin(num)
return result
                \end{lstlisting}

        \item $\begin{aligned}[t]
            arcsin(x)
        \end{aligned}$
            Located in FunctionArcsin.py

            \paragraph{}
            The Arcsin function also known as the inverse of sin can be expressed in many forms, though the form that will be used is as follows:

            \begin{center}
                $\sum_{n=0}^{\infty}\frac{1}{2^{2n}}\binom{2n}{n}\frac{x^{2n+1}}{2n+1}$
            \end{center}

            \paragraph{}
            Since we couldn’t use any of the prebuilt math functions for Python, the Taylor series and combinations were improvised by For loops. The formula above can also be shortened by  the translation of this formula which can be seen in the pseudo code in Python below. Note, for a full detailed algorithm of the arcsin, please open the FunctionArcsin.py file.

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionArcsin
Input: num, a real number, isDeg, a boolean
Output: arcsin(num)

If isDeg = True:
	Num (*$\leftarrow$*) degreeToRadians(num)
Endif

Sum (*$\leftarrow$*) 0
For n from 0 to 150 do
	A1 (*$\leftarrow$*) 1 / FunctionExponent(2, 2*n)
	A2 (*$\leftarrow$*) FunctionFactorial(2 * n) / (FunctionFactorial(n) * FunctionFactorial(n))
	A3 (*$\leftarrow$*) FunctionExponent(num, (2 * n) + 1) / ((2 * n) + 1)
	Sum (*$\leftarrow$*) sum + (A1 * A2 * A3)
return sum
            \end{lstlisting}

        \item $\begin{aligned}[t]
            MAD
        \end{aligned}$
            Located in FunctionMAD.py

            \paragraph{}
            Mean Absolute Deviation (MAD) of a dataset is the average of the absolute deviations from a central point (mean). It gives us an idea about the variability in a dataset.

            \paragraph{}
            It requires a list to evaluate the function. A syntactically correct list requires values separated by commas, inside square brackets ([]). An example of a proper syntax is [6,8,10]. And if no list is entered by the user, it returns 0.

            \paragraph{}
            The mean absolute deviation of $[x1,x2...xn]$ is:

            \begin{center}
                $MAD = \frac{\sum_{i=1}^{n}|x_i-\bar{x}|}{n}$
            \end{center}

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionMAD:
Input: arguments, a list of real numbers
Output: Mean absolute average of the list of numbers

mean (*$\leftarrow$*) 0
for every i in arguments do
	mean (*$\leftarrow$*) mean + i
od

mean (*$\leftarrow$*) mean / length(arguments)
deviation (*$\leftarrow$*) 0
for every i in arguments do
    sum (*$\leftarrow$*) i - mean
    if sum < 0 then
        sum (*$\leftarrow$*) sum * -1
    endif
    deviation (*$\leftarrow$*) deviation + sum
od
return deviation / length(self.arguments)
            \end{lstlisting}

        \item $\begin{aligned}[t]
            \sigma
        \end{aligned}$
            Located in FunctionStandardDeviation.py

            \paragraph{}
            To calculate the Standard Deviation, the first step requires the calculation of the average of a set of data points. In the algorithm, the data points are passed in as a list. Using the data points, the mean is found to introduce statistics regarding how people cluster around the average. \cite{STDVariance} The average is calculated by summing the float values of the data points given in the list, then dividing by the total number of data points in the list:

            \begin{center}
                $mean = \frac{1}{n}\sum_{i=1}^{n}x_i$
            \end{center}

            \paragraph{}
            The average is calculated with the function getMean(). Once the average is computed, we can begin the second step, calculating the standard deviation. The standard deviation is a statistic measuring the dispersion of the data points from the average:

            \begin{center}
                $\sigma = \sqrt{\frac{\sum_{i=1}^{n}(x_i - mean)^2}{n}}$
            \end{center}

            \paragraph{}
            Standard Deviation is calculated by subtracting each data point from the mean, squaring each subtraction and adding that process for every data point. Once that calculation is complete, the algorithm divides by the number of data points n, and takes the square root of that final value. The algorithm returns the standard deviation for a set of data points.

            \paragraph{}
            An example of how the algorithm pursues a list of data points:

            \paragraph{}
            Given the list a user has typed into the interpreter: $\sigma[6, 8, 10]$, the average comes first. The list is passed into the function getMean():

            \begin{center}
                $(6 + 8 + 10)/3 = 24/3 = 8$
            \end{center}

            \paragraph{}
            The standard Deviation is calculated next with the function standardDeviation():
            \begin{center}
                $\sqrt{\frac{(6-8)^2 + (8-8)^2 + (10-8)^2}{3}} = \sqrt{\frac{(-2)^2+(2)^2}{3}} = \sqrt{\frac{8}{3}} = 1.632993162$
            \end{center}

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionStandardDeviation
Input: (*$\phi$*) : List of real numbers
Output: Standard Deviation of list

mean (*$\leftarrow$*) (*$\phi$*).getAverage()
(*$\sigma$*) (*$\leftarrow$*) 0
for every datapoint in (*$\phi$*) do
	(*$\sigma$*) (*$\leftarrow$*) (*$\sigma$*) + FunctionExponent((datapoint - mean), 2)
od

Return FunctionExponent((*$\sigma$*) / length((*$\phi$*)), 0.5)
            \end{lstlisting}

        \item $\begin{aligned}[t]
            sinh(x)
        \end{aligned}$
            Located in FunctionSinh.py

            \paragraph{}
            Sinh(x), also known as Sin(x) hyperbolic, is an extension of the ordinary sin function. Whereas the Sin(x) function is defined on a circle, Sinh(x), x being in radians, is defined on a hyperbola. Sinh(x) is most notably expressed through the exponential function as follows:

            \begin{center}
                $sinh(x) = \frac{(e^x-e^{-x})}{2}$
            \end{center}

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionSinh
Input: x, a real number and isDeg, a boolean
Output: Sinh(num)

If isDeg is True then:
    num (*$\leftarrow$*) degreeToRadians(x)
Endif

num1 (*$\leftarrow$*) FunctionExponent(e, num)
num2 (*$\leftarrow$*) FunctionExponent(e, -num)
return (num1 - num2) / 2
            \end{lstlisting}

            \paragraph{}
            The algorithm for this function takes 2 parameters: the number “num” to compute and an optional boolean parameter “isDeg” specifying if the input x passed in is in degrees or not. If the boolean isDeg is true, the algorithm first converts the inputted number into radians before calculating. The function then calculates $e^x$ our custom exponential function defined using the Mclauren Series and stores it in the variable “num. Then the function calculates $e^(-x)$ the same method. The result is obtained through subtracting “num1” by “num2” and dividing this subtraction by 2.

        \item $\begin{aligned}[t]
            cosh(x)
        \end{aligned}$
            Located in FunctionCosh.py

            \paragraph{}
            Cosh(x), also known as Cos(x) hyperbolic, is an extension of the ordinary cos function. Just like Sin(x), Cosh(x) is defined on a hyperbola rather than a circle. X is als   in radians. Cosh(x) is:

            \begin{center}
                $cosh(x) = \frac{e^x+e^{-x}}{2}$
            \end{center}

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionSinh
Input: x, a real number and isDeg, a boolean
Output: Cosh(num)

If isDeg is True then:
    num (*$\leftarrow$*) degreeToRadians(x)
Endif

num1 (*$\leftarrow$*) FunctionExponent(e, num)
num2 (*$\leftarrow$*) FunctionExponent(e, -num)
return (num1 + num2) / 2
            \end{lstlisting}

            \paragraph{}
            The algorithm for this function takes 2 parameters: the number “num” to compute and an optional boolean parameter “isDeg” specifying if the input x passed in is in degrees or not. If the boolean isDeg is true, the algorithm first converts the inputted number into radians before calculating. The function then calculates $e^x$ our custom exponential function defined using the Mclauren Series and stores it in the variable “num. Then the function calculates $e^(-x)$ the same method. The result is obtained through adding “num1” by “num2” and dividing this subtraction by 2.

        \item $\begin{aligned}[t]
            tanh(x)
        \end{aligned}$
            Located in FunctionTanh.py

            \paragraph{}
            Tanh(x) is an hyperbolic function that can be derived by dividing Sinh(x) by Cosh(x)

            \begin{center}
                $tanh(x) = \frac{sinh(x)}{cosh(x)}$
            \end{center}

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionTanh
Input: x, a real number and isDeg, a boolean
Output: Tanh(num)

If isDeg is True then:
    num (*$\leftarrow$*) degreeToRadians(x)
Endif

num1 (*$\leftarrow$*) FunctionSinh(num)
num2 (*$\leftarrow$*) FunctionCosh(num)
return num1/num2
            \end{lstlisting}

            \paragraph{}
            The algorithm for this function takes 2 parameters: the number “num” to compute and an optional boolean parameter “isDeg” specifying if the input x passed in is in degrees or not. If the boolean isDeg is true, the algorithm first converts the inputted number into radians before calculating. Then, we calculate Sinh(num) and Cosh(num) and store the results in “num1” and “num2” respectively.  Finally we divide “num1” by “num2” to get the result.

        \item $\begin{aligned}[t]
            x!
        \end{aligned}$
            Located in FunctionFactorial.py

            \paragraph{}
            The factorial function is used by many other functions to do their calculations, so it was necessary to add it to the list of functions. The factorial is a simple function: For any given non-negative integer value, it does the calculation $n*(n-1)*(n-2)*...*3*2*1$, with the exception of $0!$, which equals 1. So for example, $4! = 4*3*2*1 = 24$.

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionFactorial
Input: x, an integer number
Output: x!

If x = 0 then
	Return 1
Endif

result (*$\leftarrow$*) x
i (*$\leftarrow$*) result - 1
While i > 0 do
	result (*$\leftarrow$*) result * i
	i (*$\leftarrow$*) i - 1
Od
Return result
            \end{lstlisting}

        \item $\begin{aligned}[t]
            x^y
        \end{aligned}$
            Located in FunctionExponent

            \paragraph{}
            The exponent function is used to calculate expressions of the form $x^y$. It might be straightforward at first, but only if Y is not a decimal or non-positive number. In which case the exponent can be calculated as $x*x*...*x$, done y times.

            \paragraph{}
            The exponents also have a few exceptions. For example, for any value x, $x^0=1$, and for any non-negative value y, $0^y=0$. It is impossible to calculate exponents of the form $0^x$, where x is a negative value, or if both x and y are negative values.

            \paragraph{}
            There are also a nice quirk that can be used to help in calculations, because when x is raised to a negative value, say -2, it can be simplified as $1/x^2$, so there’s no need to deal with the negative value.

            \paragraph{}
            It’s when decimal exponents are introduced that it gets complicated. There is no easy way to find the exact value of an expression with a decimal exponent, but there is a way to approximate the result with a good enough degree of accuracy for the calculator.

            \paragraph{}
            To approximate the exponential expression, we have to use a property of exponents which says that for any x and y such that $x^y, x^y = e^(y * ln(x))$ \cite{wikiE} . By putting it into this form, it allows to use something called a Taylor Series to approximate the result.

            \paragraph{}
            A Taylor Series is an equation that can be used to approximate the result of certain equations to varying degrees of precision, depending on how many iterations are done \cite{wikiS}. In the case of the exponent, we can say that:

            \begin{center}
                $x^y = e^{y*ln(x)} = \sum_{n=1}^{\infty}\frac{(y*ln(x))^{n-1}}{(n-1)!}$
            \end{center}

            \paragraph{}
            In short, if we continually do the sum of $x^(n-1)/(n-1)!$, where n increases by 1 after each sum, all the way to infinity, it will equal $x^y$. In our case, we don’t need to iterate infinity times, as we don’t need a high degree of decimal precision, therefore we can use this expression to approximate the value of $x^y$, and we can vary the number of times we iterate to increase/decrease the precision.

            \paragraph{}
        	To calculate this function, since it uses $ln(x)$, it uses the one made by the group, and !, which was also made by the group.

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionIntExponent
Input: x, real number, and y, integer
Output: x^y
If y = 0 then
	Return 1
Endif

If x = 0 then
	Return 0
Endif

result (*$\leftarrow$*) x
yabs (*$\leftarrow$*) y
If yabs < 0 then
	yabs (*$\leftarrow$*) yabs * -1
endif

i (*$\leftarrow$*) 1
For i from 1 to yabs do
	result (*$\leftarrow$*) result * x
od

If y < 0 then
	result (*$\leftarrow$*) 1 / result
endif
return result

Function FunctionExponent
Input: x and y, real numbers
Output: x^y

If x = 0 or y = 0 or y is an Integer then
	return FunctionIntExponent(x, y)
Else
	a (*$\leftarrow$*) y * FunctionLog(e, x)
	aabs (*$\leftarrow$*) a
	If aabs < 0 then
		aabs (*$\leftarrow$*) aabs * -1
	Endif
	
	sum (*$\leftarrow$*) 0
	i (*$\leftarrow$*) 1
	For i from 1 to 130 do
		sum (*$\leftarrow$*) sum + FunctionIntExponent(aabs, (i - 1))/FunctionFactorial((i - 1))
	Od
    If a < 0 then
    	sum (*$\leftarrow$*) 1 / sum
    Endif
    Return sum
Endif
            \end{lstlisting}

        \item $\begin{aligned}[t]
            log_{b}(x)
        \end{aligned}$
            Located in FunctionLog.py

            \paragraph{}
            In order to calculate the logarithm function without any prebuilt math functions, we first decided to calculate the natural logarithm [ln(x)]. Then by using the log identity:

            \begin{center}
                $log_b(n) = \frac{log_x(n)}{log_x(b)}$
            \end{center}

            \paragraph{}
            We could manipulate the formula in such a way that utilizes the natural log to give us the actual logarithmic value:

            \begin{center}
                $log_b(n) = \frac{ln(n)}{ln(b)}$
            \end{center}

            \paragraph{}
            Our next step was to figure out how to calculate the natural logarithm of any real number. We discovered that by using the Taylor series; as described in the exponential function algorithm, we could successfully compute the natural log of any real number to a high degree of accuracy. In short, by using the basic exponential function, we could easily create our own Taylor series which would give us an accurate result for the natural log in which we could compute the log of any base and value.

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function ln
Input: x (real number)
Output: Calculated ln function

sum (*$\leftarrow$*) 0
for every num in range of 1 to MAX_TERMS do:
    y (*$\leftarrow$*) (x - 1) / (x + 1)
    add (*$\leftarrow$*) FunctionExponent.FunctionExponent(y, (2*n-1)).calculateEquation()/(2*n-1)
    sum (*$\leftarrow$*) sum + add
od
return 2 * sum

Function FunctionLog
Input: base (real number) and value (real number)
Output: Calculated log function

if value > 0 and base > 1 then:
    result (*$\leftarrow$*) ln(value) / ln(base)
    return result
end if
            \end{lstlisting}

        \item $\begin{aligned}[t]
            \gamma(x)
        \end{aligned}$
            Located in FunctionGamma.py

            \paragraph{}
            The Gamma function extends the generalization of the factorial function by allowing non-negative real numbers to be calculated. The function can be calculated using the Stirling or Lanczos approximation, or using Euler's integration. In the forward description, Lanczos approximation was used.

            \paragraph{}
            If the number we need to calculate is smaller than 0.5, we use the reflection formula:

            \begin{center}
                $\Gamma(x) = \frac{\pi}{sin(\pi*x)}*\Gamma(1-x)$
            \end{center}

            \paragraph{}
            If the number is greater than or equal to 0.5, we use the algorithm below:

            \begin{lstlisting}[escapeinside={(*}{*)}]
Function FunctionGamma
Input: num - a real number
Output: The result of the gamma calculation

lanczos_coef (*$\leftarrow$*) (
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7)
if num < 0.5 then
	return (*$\pi$*) / sin((*$\pi$*) * num) * FunctionGamma(1 - num)
else
	num (*$\leftarrow$*) num - 1
	x (*$\leftarrow$*) first value of the lanczos_coef list
	For i from 1 to the length of lanczos_coef do
		x (*$\leftarrow$*) x + lanczos_coef[i] / (num + i)
	Od
	t (*$\leftarrow$*) num + length of lanczos_coef list - 1.5
	y (*$\leftarrow$*) FunctionExponent(2 * PI, 0.5) * FunctionExponent(t, num + 0.5) *
            FunctionExponent(e, -t) * x
    return y
Endif
            \end{lstlisting}

    \end{itemize}

    \subsubsection{Interpreter Algorithm}
        \paragraph{}
        The Interpreter parsed the equation inputted by the user, and calculated the result. Addition, subtraction, multiplication, division, factorial, exponent, square root,  logarithms, trigonometry, hyperbolic trigonometry, gamma, standard deviation and mean absolute deviation were functions successfully able to be applied in equations.

        \paragraph{}
        The Interpreter Algorithm is located in the InterpreterModule Folder in src. This folder contains 7 python files which all played a pivotal role with the Interpreter. These files were:

        \begin{enumerate}
            \item CharacterReader.py
            \item Tokens.py
            \item Nodes.py
            \item CreateExpression.py
            \item InterpreterErrors.py
            \item ComputeExpression.py
            \item Interpreter.py
        \end{enumerate}

        \paragraph{}
        And will be elucidated in this order. For a full detailed algorithm with comments and specifics, please open all the python files mentioned above.

        \begin{enumerate}
            \item CharacterReader.py
            \paragraph{}
            CharacterReader.py was the first of three crucial files. It was the first in the interpreter pipeline. The Interpreter algorithm begins by reading the user-inputted math expression character by character using a python generator.

            \paragraph{}
            This part of the pipeline would assign a token type to each character in the expression. These token Types can be seen in Tokens.py. If the characterReader confronted a letter in a function, (Example: a for arccos), the characterReader figured out exactly the function placed by the user and generated that function Token. If the characterReader confronted a number, the characterReader would assure that the number was inputted correctly. A Number is correctly inputted if it did not contain two decimal periods. A NUMBER Token was then generated. The characterReader would do the same for the operators encountered. Lastly, if a character was not a character that is a math expression, the characterReader would reject the math expression and raise an error.

            \item Tokens.py
            \paragraph{}
            Tokens.py contains an Enumeration class called TokenType. TokenType enumerated every possible type of token that the interpreter could read by associating to it an ID. (Examples of tokens were operators: [PLUS (+), MULTIPLICATION (*)], functions: [TRIG, SQUAREROOT], and left parentheses, right parentheses, left bracket, right bracket were considered separate tokens.)

            \paragraph{}
            This allowed tokens to have specific ID’s for easy comparison in CreateExpression.py. Tokens.py also contains the Token class, which uses the attributes Token and type. The attribute Token keeps track of the token ID and the type containing the operator or number, depending on the token. This was mostly used for debugging purposes.


            \item Nodes.py
            \paragraph{}
            Nodes.py contained the classes for every possible node. There were nodes for the operators, numbers and the functions. These nodes were to hold Number Nodes, as every mathematical operation and function need numbers, or any combination of them. These nodes would be included in the mathematical expression tree that was to be evaluated. Operator Nodes, like +, -, *, / and \^ needed two values, one on each side of the operator, while functions like Gamma, only needed one value. Values were considered as just any number, or any expression in parenthesis. Soon enough, as the complexity of the math expression increased, the tree of nodes complexified into a recursive set of nodes.

            \item CreateExpression.py
            \paragraph{}
            CreateExpression.py was the second of three crucial files. This part of the pipeline was in charge of creating the tree of the mathematical expression by following the order of operations.

            \paragraph{}
            This part of the pipeline was recursive in nature. In mathematics the order of operations are the lowest order:  plus (+), minus (-), higher order: multiplication (*), division (/), and highest order: power (\^). The first priority in creating the expression is looking for the numbers, and then the operators. If the algorithm comes into contact with any of the function tokens, in reality, the function of a number returns a number, indicating that a mathematical expression is just numbers combined with operators.

            \paragraph{}
            The algorithm would run through the generator supplying the tokens that were created with characterReader.py. The algorithm would be always keeping track of the previous token, as well as the current one.  When a number or function is found, the algorithm would check for the next token, making a recursive call to find an operator. If the next token was an operator, the algorithm would keep track of the first number encountered, and find the next inner number or inner expression in brackets. The highest order operator, power, would be concise, as it is the highest order. Meanwhile, the lowest order operations like plus and minus would be looked at last.

            \paragraph{}
            An example of a math expression would be $5+4*2+3$. This is a simple one, as no complex functions are included and parenthesis are not present. The algorithm would read the number token, 5. Then it checks for a power operator, then a multiplication/division operator. It can not find any of those, but it finds the plus operator. The algorithm creates a Node for the plus operator. The plus operator then has 5 as its first leftmost value, and is on the journey to find the rightmost value. So it calls to check for a higher order operator, as they take more precedence, as $5 + 4*2$, has to be evaluated as $(5 + (4*2))$ and not $(5+4)*2$. In this case, the algorithm does find a number token, 4, followed by a multiplication token. The number token 4 becomes the first value in the multiplication node, and the algorithm must now look for the highest priority operator, which is power. The algorithm does not find a power node, and so the number token 2 is returned as the rightmost value in the multiplication node, and the last plus operator is created with the leftmost value as $(5+(4*2))$ and the rightmost value as 3. The resulting tree is therefore $((5+(4*2)) + 3)$. This algorithm then passes this tree to computeExpression.py

            \item InterpreterErrors.py
            \paragraph{}
            InterpreterErrors.py contained all the possible errors in the three pipeline files. The error classes present in this file were for unknown elements, no expression, too many decimals, missing parenthesis and for syntax errors.

            \begin{enumerate}
                \item The Unknown Element error was raised if there was a character that was not intended for in the math expression.
                \item No Expression Error was raised if the user did not enter a valid math equation
                \item Too many decimals error was used for when generating the NUMBER token. If the characterReader found two or more decimals in a number, this error would be raised.
                \item Missing parenthesis error would be raised for a mismatching number of parenthesis
                \item Syntax Errors were any other errors that were not caught by the interpreter or for security for not crashing the ETERNITY calculator
            \end{enumerate}

            \item ComputeExpression.py
            \paragraph{}
            ComputeExpression.py was the third of three crucial files in the interpreter pipeline. This python file returned the result of the mathematical expression tree created from CreateExpression.py.

            \paragraph{}
            The basis of this algorithm was to take different paths whether the node in the tree was one of  plus node, minus node, multiplication node, division node, power node or any other. Thi is simply those operations were in charge of the order of operations and so the algorithm had to consistently check whether the second value in each of those nodes was of higher priority than itself. The algorithm would follow a depth-first search model looking through the second values until the highest priority was found, or the tree reached a leaf node. Once arrived at a leaf node, the algorithm would check the type of node it was, and compute that value. Once that value was computed it would be recursively passed into the previous function call, and used to calculate the higher nodes until only the result was left.

            \paragraph{}
            Function Nodes needed only a number value, and so if the function contained an expression in parenthesis, the algorithm would pursue the parenthesis as another expression, and calculate that one before accepting it as the function’s value.

            \item Interpreter.py
            \paragraph{}
            This python file wrapped the entire pipeline together, surrounded with a try except statement to catch the errors that could be raised. The Interpreter would begin by reading the characters in the expression, creating the tokens as it moved along. Once the list of tokens were created, the pipeline took that list, and created the proper mathematical expression tree following order of operations, until it finally calculated the result of the mathematical expression by pursuing the tree through depth first search.
        \end{enumerate}

    \subsection{UI Design}
    \paragraph{}
    The goal in making the UI this way was to make it as simple as possible, as to make sure that it would not get in the way of using the calculator. To do so, there are very few colours present in the application, only a few different shades of dark and light greys. The options to switch between light an dark styles are hidden in the menu, as to make sure that they are out of the way. Same as with the History button, and the Help and About pages.

    \paragraph{}
    With the colours being by default very dark, it is easier on the eyes of the user, with the option of switching to a lighter style if they chose so. It was also important to easily differentiate the special functions from the normal mathematical equations, therefore there is an empty space between those 2 sections. Also, to make sure that the calculator was easy to use, the texts in the labels and buttons were made larger so as to not strain the eye. The History window was made to be similar, with large texts and easily identifiable buttons so as to make it not difficult to understand what they do.


    \subsection{Source Code Review}
        \paragraph{}
        Due to the complexity of the project, software configuration management (SCM) was necessary as specified by the IEEE 828-2021 standard \cite{ieee}. This standard specified how we need to collaborate as a team on complex software It contains several sub-components, such as version control among others,

        \paragraph{}
        Version control  was a necessity in order to manage change. For this project, we used the Git branching model which is a Version Control System (VCS) . This allowed us to individually work on certain tasks as well as collaborate on others. We performed “branching” of the code in order to work on different tasks and we merged them back to the main branch once the tasks were complete.

        \paragraph{}
        It is important to note that Git was crucial to our source code review results. We used a type of Git branching known as “feature branching” which affected our source code review results. Essentially, “feature branching” deals with branches as features. Whenever we need to code 1 feature of ETERNITY, we branch the code into a feature branch, naming the branch the name of the feature to create.

        \paragraph{}
        The source code reviews were done when merging a feature branch into the main. We concluded some key results when reviewing. The following are the results:

        \begin{itemize}
            \item While reviewing a branch, some functions were redundant. For example, the sinh(x) needed to calculate  exponents  using the Mclauren series. We were calculating the Mclauren series in the FunctionSinh.py file. Upon reviewing, it was realized that another file, FunctionExponent.py had already implemented this functionality. We hence removed the redundancy.

            \item We noticed that we were using a lot of the same constants in different files, this lead us to create a parent class that contained the constants, as well as some abstract functions, that could be used by the child classes. All function classes were hence made children of the parent class.

            \item It was also noticed that the same standard was not being followed in some of the classes. In order to make it easier for the GUI manipulation, some standards were established. For example, every function class has a constructor and a separate function that computes the function in question.

            \item Upon reviewing, important comments were added to the report, using another standard established by the team. This is important because if somebody else were to work on another developer’s code, it made it easier for them to understand what was going on.
        \end{itemize}

    \subsection{Macro \& Micro Architecture}
        \paragraph{}
        Eternity Calculator is a python application built by Concordia University students. The calculator uses QT UI framework, and the project follows the Model-View-Controller(MVC) paradigm. It creates a calculator where users can input values and use a variety of basic arithmetic and transcendental functions to make calculations.

        \paragraph{}
        Talking about the Macro Architecture part of the calculator, we have 3 primary components - the User Interface, the Interpreter and the Math class. On the calculator, all the numbers are located in the bottom left corner, the basic arithmetic functions are on the bottom right and the complex transcendental functions are on the top. When the user turns on the calculator,  the finger/mind intuitively travels first to the centre, and then converges to the desired specific button. The parenthesis keys were placed above the basic arithmetic functions. The main reason behind this is, parenthesis usually encloses mathematical operations which are composed of numbers and operators. Hence, during the calculation the layout of the keys naturally follows the way a person writes mathematics, making it a more intuitive alignment between how mathematics is traditionally written and how it is typed in a calculator. The equals button (=) is placed next to the numbers for easier user access and the AC button is on the top, where calculators usually put it.

        \paragraph{}
        At the micro aspect of this project, we follow the Model-View-Controller(MVC) pattern. The interpreter acts as an intermediary here and connects the user interface to the math functions. The data is sent, interpreted and then sent to the math functions where the actual calculations are done and then returned back to the user interface through the interpreter. The user interface consists of views and controllers. Eternity users strictly interact through the views and their controllers. The model, in turn, notifies all different views and controllers about updates. Here, the GUI acts as our view, the interpreter acts as the controller and the Math functions acts as the model.

        \paragraph{}
        When building this calculator several other important architectural aspects were taken into consideration like Accuracy, Accessibility and App performance. Eternity works only on Windows at the moment and to improve user accessibility it also offers an on-screen keyboard, which has sufficient buttons to implement all functions. The Eternity is also accurate to the 6th decimal and offers an option of both Dark mode and Light mode.

    \subsection{Technical Rationale}
        \paragraph{}
        We chose to do this project in python as it was a language many of us wanted to learn and use. The language is simple and free flowing in terms of syntax and structure which allowed us to easily learn and adapt quickly to programming ETERNITY. Furthermore, a few team members were already familiar with python so any issues that we had could be quickly resolved with some research and immediate help from the team.

        \paragraph{}
        In regards to the design of the application, we all agreed that we wanted to have a graphical user interface (GUI) that could be simply run through an executable for ease of use. We agreed that Danny would handle the GUI portion of the calculator. With this in mind, we had discussed how we would be building the project from scratch and who would be in charge of what task. We determined that each member would work on their assigned function as a child class of the FunctionBase which would define some constants and other parameters to keep uniformity and continuity amongst the team. In addition we created a generic CalculationErrorException class to handle all exceptions that could be thrown by the user. Once we were all on the same page, we then discussed who would tackle the Interpreter. This was an important aspect of the project since it acts as a translation layer for the frontend and backend to properly and effectively communicate together. Nicholas took over the majority of this aspect with help from Danny. As discussed in the Interpreter Algorithm section, the interpreter's job is simply to parse the equation from the given input by the user and return the calculated result. It is crucial to note the importance of the Interpreter for this project as it is the glue that allows everything to work in conjunction with one another. With this in mind, each member began to work diligently on their assigned functions from scratch.

        \paragraph{}
        With regards to the execution and management of the project, we used GitHub for version control and source code review and Discord for our main means of communications, deadlines and scheduled meetings. As discussed previously, GitHub is a great VCS tool with many features to help simplify our task by compartmentalizing different aspects of the project for us. We chose Discord as it was a great application that we were all already using prior to our assigned team and therefore made it an easy transition to use for our all of our discussions. The accessibility made it possible to use it at any time of day, no matter where we were so we could rapidly respond to any queries as well as schedule our meetings. For the documentation, we all used Google Docs in order to simplify the completion of our administrative tasks and had a team member translate the document into LaTex form. This way we were able to alleviate the stress and discontinuities with everyone learning the micro-language at the same time and provided the members with more time to focus on their assigned tasks. In regards to the presentations we had team members volunteer for the task, they used both LaTex and Microsoft PowerPoint to create their presentations in a creative and intriguing format to captivate our audience in an effective yet professional manner.
